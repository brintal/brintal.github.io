<!DOCTYPE html>
<html>
  <head>
    <title>Sperrstund is</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="https://cdn.rawgit.com/bjornharrtell/jsts/gh-pages/1.5.0/jsts.min.js"></script>
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBIwzALxUPNbatRBj3Xi1Uhp0fFzwWNBkE&callback=initMap&libraries=geometry,places&v=weekly"
      defer
    ></script>
    <style>
    /* Always set the map height explicitly to define the size of the div
       * element that contains the map. */
#map {
  height: 100%;
}

/* Optional: Makes the sample page fill the window. */
html,
body {
  height: 100%;
  margin: 0;
  padding: 0;
}

.loader {
  border: 4px solid #f3f3f3; /* Light grey */
  border-top: 4px solid #3498db; /* Blue */
  border-radius: 50%;
  width: 20px;
  height: 20px;
  display: inline-block;
  animation: spin 2s linear infinite;
  vertical-align: middle;
  margin-left: 8px;
  margin-right: 8px;
  margin-bottom: 6px;
  visibility: hidden;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

    </style>
    <script>
    // Include the libraries=geometry,places parameter when you first load the API. For example:
// <script src="https://maps.googleapis.com/maps/api/js?key=<YOUR-API-KEY>&libraries=geometry,places">
let map;
let service;
let infowindow;

let geometryFactory;


let drawn_objects;
let circles_union;
let nr_places_total;
let running_tasks;

const minZoomLevel = 17;
const searchRadius = '500'; // Too large won't work (google maps api is limited to 60 results per query)

function initMap() {
  const center_location = new google.maps.LatLng(48.198330, 16.352444);

  // infowindow = new google.maps.InfoWindow();
  map = new google.maps.Map(document.getElementById("map"), {
    center: center_location,
    disableDefaultUI: true,
    fullscreenControl: true,
    zoom: 18,
  });
  service = new google.maps.places.PlacesService(map);
  geometryFactory = new jsts.geom.GeometryFactory()

  drawn_objects = [];
  running_tasks = 0;

  map.controls[google.maps.ControlPosition.LEFT_TOP].push(createUserControls());

  // google.maps.event.addListener(map, 'bounds_changed', () => {
  //   draw_safe_bounds();
  // });
}

function createUserControls() {
  const controlDiv = document.createElement("div");
  controlDiv.id = "userControls";
  controlDiv.style.marginTop = "8px";
  controlDiv.style.marginLeft = "8px";

  const btnRedraw = document.createElement("div");
  btnRedraw.id = "btnRedraw";
  btnRedraw.style.backgroundColor = "#fff";
  btnRedraw.style.border = "2px solid #fff";
  btnRedraw.style.borderRadius = "3px";
  btnRedraw.style.boxShadow = "0 2px 6px rgba(0,0,0,.3)";
  btnRedraw.style.cursor = "pointer";
  btnRedraw.style.marginBottom = "2px";
  btnRedraw.style.textAlign = "center";
  btnRedraw.title = "Click to redraw";
  controlDiv.appendChild(btnRedraw);
  // Set CSS for the control interior.

  const lblRedraw = document.createElement("div");
  lblRedraw.id = "lblRedraw";
  lblRedraw.style.display = "inline-block";
  lblRedraw.style.color = "rgb(25,25,25)";
  lblRedraw.style.fontFamily = "Roboto,Arial,sans-serif";
  lblRedraw.style.fontSize = "16px";
  lblRedraw.style.lineHeight = "38px";
  lblRedraw.style.paddingLeft = "8px";
  lblRedraw.style.paddingRight = "8px";
  lblRedraw.innerHTML = "Sperrstund!";
  btnRedraw.appendChild(lblRedraw);

  btnRedraw.addEventListener("click", draw_safe_bounds);

  const divLoader = document.createElement("div");
  divLoader.className = "loader";
  divLoader.id = "ldrRedraw";
  btnRedraw.appendChild(divLoader);

  const frame = document.createElement("div");
  frame.id = "frmInvert";
  frame.style.backgroundColor = "#fff";
  frame.style.border = "2px solid #fff";
  frame.style.borderRadius = "3px";
  frame.style.boxShadow = "0 2px 6px rgba(0,0,0,.3)";
  frame.style.cursor = "pointer";
  frame.style.textAlign = "left";
  controlDiv.appendChild(frame);

  const chkInvert = document.createElement("input");
  chkInvert.type = "checkbox";
  chkInvert.id = "chkInvert";
  chkInvert.checked = false;
  chkInvert.style.backgroundColor = "#fff";
  chkInvert.style.border = "2px solid #fff";
  chkInvert.style.borderRadius = "3px";
  chkInvert.style.boxShadow = "0 2px 6px rgba(0,0,0,.3)";
  chkInvert.style.cursor = "pointer";
  chkInvert.style.marginLeft = "8px";
  frame.appendChild(chkInvert);

  // Set CSS for the control interior.
  const lblInvert = document.createElement("label");
  lblInvert.for = "chkInvert";
  lblInvert.innerHTML = "invers";
  lblInvert.style.color = "rgb(25,25,25)";
  lblInvert.style.fontFamily = "Roboto,Arial,sans-serif";
  lblInvert.style.fontSize = "16px";
  lblInvert.style.lineHeight = "38px";
  lblInvert.style.paddingLeft = "5px";
  lblInvert.style.paddingRight = "5px";
  frame.appendChild(lblInvert);

  return controlDiv;
}


function task_statistics(diff) {
  running_tasks += diff;
  if (running_tasks > 0) {
    document.getElementById("ldrRedraw").style.visibility = "visible";
  } else {
    document.getElementById("ldrRedraw").style.visibility = "hidden";
  }
}

function draw_safe_bounds() {
  circles_union = geometryFactory.createMultiPolygon();
  if (map.getZoom() < minZoomLevel) {
    console.log("Zoom level exceeded: ", map.getZoom());
    map.setZoom(minZoomLevel);
  }
  nr_places_total = 0;
  searchPlaces();
}


function circle(location) {
  const sides = 20;
  const radius = 50; // meters
  var points = [];
  for(var i = 0, d = 0, p = 360 / sides; i < sides; ++i, d += p){
      var point = google.maps.geometry.spherical.computeOffset(location, radius, d);
      points.push(new jsts.geom.Coordinate(point.lat(), point.lng()));
  }
  points.push(points[0]); // Close circle
  return geometryFactory.createPolygon(points);
}

function randomFromInterval(min, max) { // min and max included
  return Math.random() * (max - min) + min;
}

function addRandomPlaces(nr, bounds) {
  var circles = [];
  for (var i = 0; i < nr; i++) {
    lat = randomFromInterval(bounds.getNorthEast().lat(), bounds.getSouthWest().lat());
    lng = randomFromInterval(bounds.getNorthEast().lng(), bounds.getSouthWest().lng());
    circles.push(circle(new google.maps.LatLng(lat, lng)));
  }
  return circles;
}

function searchPlaces() {
  // const place_types = ["cafe"]
  const place_types = ["bar", "cafe", "night_club", "restaurant"]
  place_types.forEach(place_type => {
    task_statistics(+1);
    const request = {
      location: map.getBounds().getCenter(),
      radius: searchRadius,
      type: place_type
    };

    var nr_places = 0;
    service.nearbySearch(request, (results, status, pagination) => {
      var circles = [];
      if (status === google.maps.places.PlacesServiceStatus.REQUEST_DENIED) {
        // Debugging
        // circles = circles.concat(addRandomPlaces(80, map.getBounds()));
        task_statistics(-1);
      } else if (status === google.maps.places.PlacesServiceStatus.OK) {
        for (let i = 0; i < results.length; i++) {
          circles.push(circle(results[i].geometry.location));
          nr_places++;
        }
        if (pagination.hasNextPage) {
          task_statistics(+1);
          setTimeout(() => {
            pagination.nextPage();
          }, 2000);
        }
      }
      draw(geometryFactory.createMultiPolygon(circles).union());
      console.log(`Finished search for ${place_type}s, got ${nr_places} places.`);
      nr_places_total += nr_places;
    });
  });
}

function convert_j2g_ring_points(ring) {
  if ( ring.getGeometryType() != "LinearRing") {
    throw new Error(`Can only convert LinearRing type, but got "${ring.getGeometryType()}"`);
  }
  var gm_ring = [];
  ring.getCoordinates().forEach(point => {
    gm_ring.push({lat: point.x, lng: point.y});
  });
  return gm_ring;
}

function convert_j2g_geometry(geom, color) {
  // Returns an array of google-maps geometries
  const geom_type = geom.getGeometryType();
  var gm_geom = [];
  switch (geom_type) {
    case "MultiPolygon":
      for (var i = 0; i < geom.getNumGeometries(); i++) {
        gm_geom = gm_geom.concat(convert_j2g_geometry(geom.getGeometryN(i), color));
      }
      break;
    case "Polygon":
      var rings = [];
      rings.push(convert_j2g_ring_points(geom.getExteriorRing()));
      for (var i = 0; i < geom.getNumInteriorRing(); i++) {
        rings.push(convert_j2g_ring_points(geom.getInteriorRingN(i)));
      }

      gm_geom.push(new google.maps.Polygon({
        paths: rings,
        strokeColor: color,
        strokeOpacity: 0.8,
        strokeWeight: 2,
        fillColor: color,
        fillOpacity: 0.35,
      }));
      // gm_geom.push(new google.maps.Data.Polygon(rings));
      break;
    case "GeometryCollection":
      if (geom.getNumGeometries()) {
        throw new Error(`GeometryCollections are not supported (unless empty).`);
      }
      break;
    default:
      throw new Error(`Geometry type "${geom_type}" is not supported.`);
  }
  return gm_geom;
}

function wipe_drawn_objects() {
  drawn_objects.forEach(object => {
    object.setMap(null);
  });
  drawn_objects = []
}

function draw(circles_multipoly) {
  var base;
  var geometries;

  circles_union = circles_union.union(circles_multipoly);

  var invert_circles = document.getElementById("chkInvert").checked;

  if (invert_circles) {
    const bounds = map.getBounds();
    const lat0 = bounds.getNorthEast().lat();
    const lng0 = bounds.getNorthEast().lng();
    const lat1 = bounds.getSouthWest().lat();
    const lng1 = bounds.getSouthWest().lng();

    viewport_poly = [
      new jsts.geom.Coordinate(lat0, lng0),
      new jsts.geom.Coordinate(lat0, lng1),
      new jsts.geom.Coordinate(lat1, lng1),
      new jsts.geom.Coordinate(lat1, lng0),
      new jsts.geom.Coordinate(lat0, lng0),
    ];

    base = geometryFactory.createPolygon(viewport_poly);
    base = base.difference(circles_union);
    geometries = convert_j2g_geometry(base, "#099c47");
  } else {
    base = circles_union;
    geometries = convert_j2g_geometry(base, "#cf0e00");
  }

  wipe_drawn_objects();
  geometries.forEach(geom => {
    geom.setMap(map);
    drawn_objects.push(geom);
  });
  task_statistics(-1);
  console.log(`Finished drawing ${nr_places_total} places, ${geometries.length} geometries.`);
}

    </script>
    <!-- jsFiddle will insert css and js -->
  </head>
  <body>
    <div id="map"></div>
  </body>
</html>
